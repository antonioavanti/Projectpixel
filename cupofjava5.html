<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Performance</title>
	<link rel="stylesheet" href="cupofjava.css">
	<link rel="stylesheet" href="https://use.typekit.net/riu7bcu.css">
</head>
<body>
	<header>
		<h1>PERFORMANCE</h1>

			<ul id="headerList">
				<li class="subHeading">Adding Page content</li>
				<li class="subHeading">Reflow and Repaint</li>
				<li class="subHeading">The Call Stack</li>
				<li class="subHeading">The event Loop</li>
				<li class="subHeading">setTimeout</li>
			</ul>
	</header>

<main>

	<h2>Using A Loop To Add Content</h2>
	<p>
		<b>for (let i = 1; i <= 200; i++) {<br>
    	const newElement = document.createElement('p');<br>
    	newElement.textContent = 'This is paragraph number ' + i;<br><br>

    	document.body.appendChild(newElement);<br>
		}</b><br><br>

		This code:<br><br>
		<ul>
			<li>creates a paragraph element</li>
			<li>adds some text to the paragraph</li>
			<li>adds the paragraph to the page</li>
		</ul><br><br>

		...and it does this two hundred times.<br><br>

		Since we want two hundred things done, the best way to do this is with a for loop, so that code is inescapable. However, the code inside the for loop is not all that efficient, and there are quite a few things we could do to improve this code. We could:<br><br>

		<ul>
			<li>create some parent container element outside of the loop</li>
			<li>we could append all new paragraph elements to this parent container</li>
			<li>we append this parent container to the <-body> element instead of appending each time through the loop</li>
		</ul><br><br>

		Let's see all the above changes:<br><br>

		<b>
			const myCustomDiv = document.createElement('div');

			for (let i = 1; i <= 200; i++) {<br>
			  const newElement = document.createElement('p');<br>
			  newElement.innerText = 'This is paragraph number ' + i;<br><br>

			  myCustomDiv.appendChild(newElement);<br>
			}<br>

			document.body.appendChild(myCustomDiv);
		</b>
	</p>
	<h2>DocumentFragment</h2>
	<p>A document fragment represents a minimale document object that has no parent. It is used as a lightweight version of the document that stores a segment of a document structure comprised off nodes just like a standard document.The key difference is that because the document fragment isn't part of the active document tree structure, changes made to the fragment don't affect the document, cause reflow, or incur any performance impact that can occur when changes are made. </p>
	<p>In other words, changes made to a DocumentFragment happen off-screen; there's no reflow and repaint cost while you build this. So this is exactly what we need!<br>

	We can use the .createDocumentFragment() method to create an empty DocumentFragment object. See example in 5js.</p>


<script type="text/javascript" src="cupofjava5.js"></script>

<h2>Reflow and Repaint</h2>

<p>
	Reflow is the process of the browser laying out the page. It happens when you first display the DOM (generally after the DOM and CSS have been loaded), and happens again every time something could change the layout. This is a fairly expensive (slow) process.<br><br>

	Repaint happens after reflow as the browser draws the new layout to the screen. This is fairly quick, but you still want to limit how often it happens.<br><br>

	For example, if you add a CSS class to an element, the browser often recalculates the layout of the entire pageâ€”that's one reflow and one repaint!
</p>
<p>
	Let's take a realistic example. Say you're writing the next great blogging platform, and you want to have a "remove spam" button for the administrator. Your HTML looks like this:
	<div id="comments">
	  <div class="comment"> The great is in the house </div>
	  <div class="comment"> The great is getting married </div>
	  <div class="comment"> The great is going to be a dad </div>
	</div>
</p>
<p>
	When we run the spam filter, we discover comments one and two have to be removed.<br><br>

	If we simply call .removeChild() for each of the two comments that need to be removed, that's one reflow and one repaint for each change (so a total of 2 reflows and 2 repaints). We could rebuild the whole thing in a DocumentFragment and replace #comments -- that's the time to rebuild (possibly involving reading files or data), plus at least one reflow and one repaint.<br><br>

	Or we could hide #comments, delete the spam, and show it again -- that's surprisingly fast, to the cost of one reflow and two repaints (and little else). It's fast because hiding doesn't change the layout, it just erases that section of the screen (1 repaint). When you make the changed section visible again, that's a reflow and a repaint.
</p>

<h2>The Call Stack</h2>
<h3>Single Threading</h3>
<p>
	JavaScript is Single threaded. According to Wikipedia, single-threading is <em>the processng of one command at a time. <a href="https://en.wikipedia.org/wiki/Thread_(computing)#Single_threading">(source)</a></em>.
</p>
<p>
	Keeping JavaScript's single-threaded nature in mind (meaning it can only perform one task at a time), let's break down this code into the order it will run:
	<ul>
		<li>the <b>addParagraph()</b> function is declared on line 1</li>
		<li>the <b>appendNewMessage()</b> function is declared on line 6</li>
		<li><b>addParagraph()</b> is called on line 13
			<ul>
				<li>execution moves into the function and executes all three lines in order</li>
				<li>now that the function is finished, execution returns to where it was called</li>
			</ul>
		</li>
		<li>the <b>appendNewMessage()</b> function is called on line 14
			<ul>
				<li>execution moves into the function and executes all three lines in order</li>
				<li>now that the function is finished, execution returns to where it was called</li>
			</ul>
		</li>
		<li>the program ends because all lines of code have been executed</li>

	</ul>
	<br>
	 When addParagraph() is invoked on line 13, all of the code in the function gets executed: it doesn't just execute some lines and leave other lines to be executed later. The entire block of code is run. A second thing I want to point out is that addParagraph() is invoked, runs, and finishes before appendNewMessage() is invoked (including a possible reflow and repaint); JavaScript doesn't execute multiple lines/functions at the same time (this is single-threading...processing one command at a time!).
</p>
</main>
	<footer>
		<h3>Notes by Antonio Avanti</h3>
	</footer>
</body>
</html>