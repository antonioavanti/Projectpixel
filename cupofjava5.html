<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Performance</title>
	<link rel="stylesheet" href="cupofjava.css">
	<link rel="stylesheet" href="https://use.typekit.net/riu7bcu.css">
</head>
<body>
	<header>
		<h1>PERFORMANCE</h1>

			<ul id="headerList">
				<li class="subHeading">Adding Page content</li>
				<li class="subHeading">Reflow and Repaint</li>
				<li class="subHeading">The Call Stack</li>
				<li class="subHeading">The event Loop</li>
				<li class="subHeading">setTimeout</li>
			</ul>
	</header>

<main>

	<h2>Using A Loop To Add Content</h2>
	<p>
		<b>for (let i = 1; i <= 200; i++) {<br>
    	const newElement = document.createElement('p');<br>
    	newElement.textContent = 'This is paragraph number ' + i;<br><br>

    	document.body.appendChild(newElement);<br>
		}</b><br><br>

		This code:<br><br>
		<ul>
			<li>creates a paragraph element</li>
			<li>adds some text to the paragraph</li>
			<li>adds the paragraph to the page</li>
		</ul><br><br>

		...and it does this two hundred times.<br><br>

		Since we want two hundred things done, the best way to do this is with a for loop, so that code is inescapable. However, the code inside the for loop is not all that efficient, and there are quite a few things we could do to improve this code. We could:<br><br>

		<ul>
			<li>create some parent container element outside of the loop</li>
			<li>we could append all new paragraph elements to this parent container</li>
			<li>we append this parent container to the <-body> element instead of appending each time through the loop</li>
		</ul><br><br>

		Let's see all the above changes:<br><br>

		<b>
			const myCustomDiv = document.createElement('div');

			for (let i = 1; i <= 200; i++) {<br>
			  const newElement = document.createElement('p');<br>
			  newElement.innerText = 'This is paragraph number ' + i;<br><br>

			  myCustomDiv.appendChild(newElement);<br>
			}<br>

			document.body.appendChild(myCustomDiv);
		</b>
	</p>
	<h2>DocumentFragment</h2>
	<p>A document fragment represents a minimale document object that has no parent. It is used as a lightweight version of the document that stores a segment of a document structure comprised off nodes just like a standard document.The key difference is that because the document fragment isn't part of the active document tree structure, changes made to the fragment don't affect the document, cause reflow, or incur any performance impact that can occur when changes are made. </p>
	<p>In other words, changes made to a DocumentFragment happen off-screen; there's no reflow and repaint cost while you build this. So this is exactly what we need!<br>

	We can use the .createDocumentFragment() method to create an empty DocumentFragment object. See example in 5js.</p>


<script type="text/javascript" src="cupofjava5.js"></script>

<h2>Reflow and Repaint</h2>

<p>
	Reflow is the process of the browser laying out the page. It happens when you first display the DOM (generally after the DOM and CSS have been loaded), and happens again every time something could change the layout. This is a fairly expensive (slow) process.<br><br>

	Repaint happens after reflow as the browser draws the new layout to the screen. This is fairly quick, but you still want to limit how often it happens.<br><br>

	For example, if you add a CSS class to an element, the browser often recalculates the layout of the entire pageâ€”that's one reflow and one repaint!
</p>
<p>
	Let's take a realistic example. Say you're writing the next great blogging platform, and you want to have a "remove spam" button for the administrator. Your HTML looks like this:
	<div id="comments">
	  <div class="comment"> The great is in the house </div>
	  <div class="comment"> The great is getting married </div>
	  <div class="comment"> The great is going to be a dad </div>
	</div>
</p>
<p>
	When we run the spam filter, we discover comments one and two have to be removed.<br><br>

	If we simply call .removeChild() for each of the two comments that need to be removed, that's one reflow and one repaint for each change (so a total of 2 reflows and 2 repaints). We could rebuild the whole thing in a DocumentFragment and replace #comments -- that's the time to rebuild (possibly involving reading files or data), plus at least one reflow and one repaint.<br><br>

	Or we could hide #comments, delete the spam, and show it again -- that's surprisingly fast, to the cost of one reflow and two repaints (and little else). It's fast because hiding doesn't change the layout, it just erases that section of the screen (1 repaint). When you make the changed section visible again, that's a reflow and a repaint.
</p>

<h2>The Call Stack</h2>
<h3>Single Threading</h3>
<p>
	JavaScript is Single threaded. According to Wikipedia, single-threading is <em>the processng of one command at a time. <a href="https://en.wikipedia.org/wiki/Thread_(computing)#Single_threading" target="blank">(source)</a></em>.
</p>
<p>
	Keeping JavaScript's single-threaded nature in mind (meaning it can only perform one task at a time), let's break down this code into the order it will run:
	<ul>
		<li>the <b>addParagraph()</b> function is declared on line 1</li>
		<li>the <b>appendNewMessage()</b> function is declared on line 6</li>
		<li><b>addParagraph()</b> is called on line 13
			<ul>
				<li>execution moves into the function and executes all three lines in order</li>
				<li>now that the function is finished, execution returns to where it was called</li>
			</ul>
		</li>
		<li>the <b>appendNewMessage()</b> function is called on line 14
			<ul>
				<li>execution moves into the function and executes all three lines in order</li>
				<li>now that the function is finished, execution returns to where it was called</li>
			</ul>
		</li>
		<li>the program ends because all lines of code have been executed</li>

	</ul>
	<br>
	 When addParagraph() is invoked on line 13, all of the code in the function gets executed: it doesn't just execute some lines and leave other lines to be executed later. The entire block of code is run. A second thing I want to point out is that addParagraph() is invoked, runs, and finishes before appendNewMessage() is invoked (including a possible reflow and repaint); JavaScript doesn't execute multiple lines/functions at the same time (this is single-threading...processing one command at a time!).
</p>
<h2>The Event Loop</h2>
<h3>Code Synchronicity</h3>
<p>
	Asynchronous code makes use of the JavaScript Event Loop. Any asynchronous code (like setTimeout or the function passed to .addEventListener()) is handled by the browser. When this asynchronous code is ready to be executed, it's moved to the queue where it waits until the Call Stack is empty. Whenever the Call Stack is empty, code moves from the Queue over to the Call Stack and gets executed.For example:<br><br>

	const links = document.querySelectorAll('input');<br>
	const thirdField = links[2];<br><br>

	thirdField.addEventListener('keypress', function handleKeyPresses(event) {<br>
    console.log('a key was pressed');<br>
	});<br><br>

	Most of this code is synchronous but the event listener handleKeyPress is not invoked immediately. It's invoked if/when there's a keypress.
</p>

<h3>The JavaScript Event Loop</h3>

</p>
	The simplest explanation of JavaScript's concurrency model uses two rules: If some JavaScript is running, let it run until it is finished ("run-to-completion"). If no JavaScript is running, run any pending event handlers.<br>
	Since most JavaScript is run in response to an event, this is known as an event loop: Pick up the next event, run its handler, and repeat.
<p>

<h2>setTimeout</h2>
<h3>Running code later</h3>
<ul>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/setTimeout" target="blank">MDN docs</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="blank">Concurrency model & Event Loop</a></li>
	<li><a href="https://javascript.info/settimeout-setinterval" target="blank">Scheduling: setTimeout and setinterval</a></li>
</ul>
<p>
	The setTimeout() function takes:
	<ul>
		<li>a function to run at some later time</li>
		<li>the number of milliseconds the code should wait before running the function</li>
	</ul>

	See example in 5js--58
</p>
<h3>Breaking up Long-running code</h3>
<p>
	While JavaScript is running, the page is "busy" and the user won't be able to interact with the page (e.g. clicking a button, filling out a form). Remember that this is because JavaScript runs synchronously. So it will run to completion (creating, appending, and inserting all twenty thousand elements), and it does this before it is able to respond to any actions the user has taken. The function that creates all of these elements and adds them to the page will be in the Call Stack until it's completely finished.One way to give the user a chance to interact with the page is to break up the adding of the content into chunks using <b>setTimeout()</b><br><br>

	See example in 5js---62
</p>



</main>
	<footer>
		<h3>Notes by Antonio Avanti</h3>
	</footer>
</body>
</html>